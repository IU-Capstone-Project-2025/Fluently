name: Deploy

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: false
        default: "main"
        type: string
      environment:
        description: "Deployment environment (production/staging)"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - production
          - staging
      dry_run:
        description: "Dry run - build images but don't deploy"
        required: false
        default: false
        type: boolean
      skip_tests:
        description: "Skip quality checks and tests (faster deployment)"
        required: false
        default: false
        type: boolean
      force_build_backend:
        description: "Force rebuild backend image"
        required: false
        default: false
        type: boolean
      force_build_telegram:
        description: "Force rebuild telegram-bot image"
        required: false
        default: false
        type: boolean
      force_build_ml_api:
        description: "Force rebuild ML API image"
        required: false
        default: false
        type: boolean
      force_build_nginx:
        description: "Force rebuild nginx image"
        required: false
        default: false
        type: boolean
      force_build_all:
        description: "Force rebuild all images"
        required: false
        default: false
        type: boolean
      rebuild_containers:
        description: "Rebuild containers during deployment (--build flag)"
        required: false
        default: false
        type: boolean

jobs:
  # Determine deployment environment
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      domain: ${{ steps.env.outputs.domain }}
    steps:
      - name: Determine environment
        id: env
        run: |
          BRANCH="${{ github.event.inputs.branch || github.ref_name }}"
          ENV_INPUT="${{ github.event.inputs.environment }}"
          
          # Auto-determine environment based on branch if not manually specified
          if [ "$ENV_INPUT" = "auto" ] || [ -z "$ENV_INPUT" ]; then
            if [ "$BRANCH" = "main" ]; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
          else
            ENVIRONMENT="$ENV_INPUT"
          fi
          
          # Set environment-specific variables
          if [ "$ENVIRONMENT" = "production" ]; then
            DOMAIN="fluently-app.ru"
            HOST="${{ secrets.DEPLOY_HOST }}"
            USERNAME="${{ secrets.DEPLOY_USERNAME }}"
            ZEROTIER_IP="${{ secrets.ZEROTIER_IP }}"
          else
            DOMAIN="fluently-app.online"
            HOST="${{ secrets.STAGING_DEPLOY_HOST }}"
            USERNAME="${{ secrets.STAGING_DEPLOY_USERNAME }}"
            ZEROTIER_IP="${{ secrets.STAGING_ZEROTIER_IP }}"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT

  # Code quality analysis
  quality-check:
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          cache: true  # Enable Go module caching
          cache-dependency-path: backend/go.sum

      - name: Install swag for Go docs generation
        run: |
          echo "üì¶ Installing swag..."
          go install github.com/swaggo/swag/cmd/swag@latest
          echo "‚úÖ Swag installed to: $(which swag || echo '$HOME/go/bin/swag')"

      - name: Initialize Go module and generate docs
        working-directory: ./backend
        run: |
          # Add Go bin to PATH
          export PATH=$PATH:$HOME/go/bin
          
          # Ensure Go modules are properly initialized
          echo "üì¶ Ensuring Go dependencies are available..."
          go mod download
          go mod tidy
          
          # Debug: Verify we're in the right place and files exist
          echo "üîç Current working directory: $(pwd)"
          echo "üîç Go version: $(go version)"
          echo "üîç Checking for main.go:"
          test -f cmd/main.go && echo "‚úÖ cmd/main.go exists" || echo "‚ùå cmd/main.go missing"
          
          # Verify swag is available
          echo "üîç Checking swag installation:"
          if command -v swag >/dev/null 2>&1; then
            echo "‚úÖ swag found in PATH: $(which swag)"
          elif [ -f "$HOME/go/bin/swag" ]; then
            echo "‚úÖ swag found at: $HOME/go/bin/swag"
          else
            echo "‚ùå swag not found"
            exit 1
          fi
          
          # Create docs directory if it doesn't exist
          mkdir -p docs
          
          # Generate Swagger documentation with proper directory specification
          echo "üìö Generating API documentation..."
          echo "Current directory: $(pwd)"
          echo "Contents of current directory:"
          ls -la
          echo "Contents of cmd directory:"
          ls -la cmd/
          if command -v swag >/dev/null 2>&1; then
            swag init -g ./cmd/main.go -o ./docs --parseDependency --parseInternal
          else
            $HOME/go/bin/swag init -g ./cmd/main.go -o ./docs --parseDependency --parseInternal
          fi
          
          # Verify docs were generated
          if [ ! -d "docs" ] || [ ! -f "docs/swagger.json" ]; then
            echo "‚ùå Failed to generate docs properly"
            echo "üîç Contents of docs directory:"
            ls -la docs/ || echo "docs directory not found"
            exit 1
          fi
          
          echo "‚úÖ Documentation generated successfully"
          echo "üìÅ Generated files:"
          ls -la docs/

      - name: Start test database
        run: |
          docker compose -f docker-compose.test.yml down --volumes
          docker compose -f docker-compose.test.yml up -d
        
      - name: Wait for DB to become healthy
        run: |
          for i in {1..20}; do
            docker inspect -f '{{json .State.Health.Status}}' fluently_test_db | grep -q healthy && break
            sleep 3
          done
        
      - name: Seed test database
        working-directory: ./backend
        env:
          DB_HOST: localhost
          DB_PORT: 5433
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_fluently_db
          DB_TEST_HOST: localhost
          DB_TEST_PORT: 5433
          DB_TEST_USER: test_user
          DB_TEST_PASSWORD: test_password
          DB_TEST_NAME: test_fluently_db
        run: |
          echo "üå± Seeding test database with sample data..."
          
          # Check if we have a database seeding/migration mechanism
          if [ -f "init.sql" ]; then
            echo "üìù Found init.sql, applying database schema..."
            PGPASSWORD=test_password psql -h localhost -p 5433 -U test_user -d test_fluently_db -f init.sql
          fi
          
          # If there's a seeding script or migration tool, run it
          if [ -f "cmd/import/main.go" ]; then
            echo "üîß Running database import tool..."
            go run cmd/import/main.go || echo "‚ö†Ô∏è Import tool failed, continuing with empty database"
          fi
          
          # Alternative: Check if we can run migrations
          if command -v migrate &> /dev/null && [ -d "migrations" ]; then
            echo "üîß Running database migrations..."
            migrate -path migrations -database "postgres://test_user:test_password@localhost:5433/test_fluently_db?sslmode=disable" up || echo "‚ö†Ô∏è Migrations failed, continuing"
          fi
          
          echo "‚úÖ Database seeding completed"
        
      - name: Go tests with coverage
        working-directory: ./backend
        env:
          # Generic DB variables (used by code that doesn't look at *_TEST_*)
          DB_HOST: localhost
          DB_PORT: 5433
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_fluently_db

          # Explicit *_TEST_* variables (preferred by new config helpers)
          DB_TEST_HOST: localhost
          DB_TEST_PORT: 5433
          DB_TEST_USER: test_user
          DB_TEST_PASSWORD: test_password
          DB_TEST_NAME: test_fluently_db
          
          # Set test mode to help tests initialize their own data
          GO_ENV: test
          TEST_MODE: true
                    
          # JWT configuration for tests
          JWT_SECRET: ${{ secrets.TEST_JWT_SECRET }}
        run: |
          echo "üß™ Running Go tests with coverage..."
          
          # Install PostgreSQL client if needed for database operations
          if ! command -v psql &> /dev/null; then
            sudo apt-get update
            sudo apt-get install -y postgresql-client
          fi
          
          # Run tests with proper coverage collection including external test packages
          # Use -coverpkg flag to include all packages in coverage
          go test ./... -v -coverprofile=coverage.out -covermode=atomic -coverpkg=./... || {
            echo "‚ùå Tests failed, showing database state for debugging..."
            echo "üîç Checking if database is accessible..."
            PGPASSWORD=test_password psql -h localhost -p 5433 -U test_user -d test_fluently_db -c "SELECT version();" || echo "‚ùå Database connection failed"
            
            echo "üîç Checking database tables..."
            PGPASSWORD=test_password psql -h localhost -p 5433 -U test_user -d test_fluently_db -c "\dt" || echo "‚ùå Failed to list tables"
            
            echo "üîç Checking test database logs..."
            docker logs fluently_test_db --tail=50 || true
            
            # Re-run tests to get the actual failure
            exit 1
          }
          
          go tool cover -func=coverage.out
        
      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN:  ${{ secrets.SONAR_TOKEN }}
        
      - name: Stop test database & wipe volume
        if: always()
        run: docker compose -f docker-compose.test.yml down --volumes

  # ===========================================
  # BUILD STAGE - Build Docker images for staging and production
  # ===========================================
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: setup
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    outputs:
      backend-built: ${{ steps.build-flags.outputs.backend-built }}
      telegram-built: ${{ steps.build-flags.outputs.telegram-built }}
      ml-api-built: ${{ steps.build-flags.outputs.ml-api-built }}
      nginx-built: ${{ steps.build-flags.outputs.nginx-built }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for change detection

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Determine what to build
        id: build-flags
        run: |
          # Initialize change flags
          BACKEND_CHANGED="false"
          TELEGRAM_CHANGED="false"
          ML_API_CHANGED="false"
          NGINX_CHANGED="false"
          
          # Check for file changes if this is a push event
          if [ "${{ github.event_name }}" = "push" ]; then
            # Get the previous commit for comparison
            if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              BASE_SHA="${{ github.event.before }}"
              echo "üîç Checking for changes since $BASE_SHA"
              
              # Check for backend changes
              if git diff --name-only $BASE_SHA HEAD | grep -q "^backend/"; then
                BACKEND_CHANGED="true"
                echo "üî® Backend files changed"
              fi
              
              # Check for telegram bot changes
              if git diff --name-only $BASE_SHA HEAD | grep -q "^telegram-bot/"; then
                TELEGRAM_CHANGED="true"
                echo "üî® Telegram bot files changed"
              fi
              
              # Check for ML API changes
              if git diff --name-only $BASE_SHA HEAD | grep -q "^analysis/distractor_api/"; then
                ML_API_CHANGED="true"
                echo "üî® ML API files changed"
              fi
              
              # Check for nginx changes
              if git diff --name-only $BASE_SHA HEAD | grep -q -E "^(frontend-website/|backend/nginx-container/)"; then
                NGINX_CHANGED="true"
                echo "üî® Nginx files changed"
              fi
            else
              # First commit or force push - build everything
              echo "üî® First commit or force push detected - building all images"
              BACKEND_CHANGED="true"
              TELEGRAM_CHANGED="true"
              ML_API_CHANGED="true"
              NGINX_CHANGED="true"
            fi
          else
            echo "üìù Manual workflow dispatch - using force build flags only"
          fi
          
          # Determine final build decisions based on changes + force flags
          BUILD_BACKEND="false"
          BUILD_TELEGRAM="false"
          BUILD_ML_API="false"
          BUILD_NGINX="false"
          
          # Force build all images
          if [ "${{ github.event.inputs.force_build_all }}" = "true" ]; then
            BUILD_BACKEND="true"
            BUILD_TELEGRAM="true"
            BUILD_ML_API="true"
            BUILD_NGINX="true"
            echo "üî® Force building all images"
          else
            # Individual force flags or changes
            if [ "${{ github.event.inputs.force_build_backend }}" = "true" ] || [ "$BACKEND_CHANGED" = "true" ]; then
              BUILD_BACKEND="true"
              if [ "${{ github.event.inputs.force_build_backend }}" = "true" ]; then
                echo "üî® Force building backend"
              else
                echo "üî® Building backend (changed)"
              fi
            fi
            
            if [ "${{ github.event.inputs.force_build_telegram }}" = "true" ] || [ "$TELEGRAM_CHANGED" = "true" ]; then
              BUILD_TELEGRAM="true"
              if [ "${{ github.event.inputs.force_build_telegram }}" = "true" ]; then
                echo "üî® Force building telegram bot"
              else
                echo "üî® Building telegram bot (changed)"
              fi
            fi
            
            if [ "${{ github.event.inputs.force_build_ml_api }}" = "true" ] || [ "$ML_API_CHANGED" = "true" ]; then
              BUILD_ML_API="true"
              if [ "${{ github.event.inputs.force_build_ml_api }}" = "true" ]; then
                echo "üî® Force building ML API"
              else
                echo "üî® Building ML API (changed)"
              fi
            fi
            
            if [ "${{ github.event.inputs.force_build_nginx }}" = "true" ] || [ "$NGINX_CHANGED" = "true" ]; then
              BUILD_NGINX="true"
              if [ "${{ github.event.inputs.force_build_nginx }}" = "true" ]; then
                echo "üî® Force building nginx"
              else
                echo "üî® Building nginx (changed)"
              fi
            fi
          fi
          
          # Output build decisions
          echo "backend-built=$BUILD_BACKEND" >> $GITHUB_OUTPUT
          echo "telegram-built=$BUILD_TELEGRAM" >> $GITHUB_OUTPUT
          echo "ml-api-built=$BUILD_ML_API" >> $GITHUB_OUTPUT
          echo "nginx-built=$BUILD_NGINX" >> $GITHUB_OUTPUT
          
          # Summary
          echo "üìã Build Summary:"
          echo "  Backend: $BUILD_BACKEND"
          echo "  Telegram Bot: $BUILD_TELEGRAM"
          echo "  ML API: $BUILD_ML_API"
          echo "  Nginx: $BUILD_NGINX"

      # Backend Build
      - name: Build and push backend image
        if: steps.build-flags.outputs.backend-built == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            docker.io/fluentlyorg/fluently-backend:latest-develop
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # Telegram Bot Build  
      - name: Build and push telegram-bot image
        if: steps.build-flags.outputs.telegram-built == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./telegram-bot
          file: ./telegram-bot/Dockerfile
          push: true
          tags: |
            docker.io/fluentlyorg/fluently-telegram-bot:latest-develop
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # ML API Build (Most expensive - 15 minutes)
      - name: Build and push ML API image
        if: steps.build-flags.outputs.ml-api-built == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./analysis
          file: ./analysis/distractor_api/Dockerfile
          push: true
          tags: |
            docker.io/fluentlyorg/fluently-ml-api:latest-develop
          cache-from: type=gha
          cache-to: type=gha,mode=min
          platforms: linux/amd64

      # Nginx Build
      - name: Build and push nginx image
        if: steps.build-flags.outputs.nginx-built == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./backend/nginx-container/Dockerfile
          push: true
          tags: |
            docker.io/fluentlyorg/fluently-nginx:latest-develop
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Build summary
        run: |
          echo "‚úÖ Build stage completed"
          echo "üî® Built images:"
          [ "${{ steps.build-flags.outputs.backend-built }}" = "true" ] && echo "  - Backend" || true
          [ "${{ steps.build-flags.outputs.telegram-built }}" = "true" ] && echo "  - Telegram Bot" || true
          [ "${{ steps.build-flags.outputs.ml-api-built }}" = "true" ] && echo "  - ML API" || true
          [ "${{ steps.build-flags.outputs.nginx-built }}" = "true" ] && echo "  - Nginx" || true
          
          # Dry run notification
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo ""
            echo "üß™ DRY RUN MODE: Images built but deployment will be skipped"
            echo "‚úÖ This was a successful dry run - images are ready for deployment"
          fi

  deploy:
    needs: [setup, quality-check, build]
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    if: github.event.inputs.dry_run != 'true' && always() && !failure() && !cancelled()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug values
        run: |
          echo "üîç Deployment Information:"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Domain: ${{ needs.setup.outputs.domain }}"
          echo "Branch: ${{ github.event.inputs.branch || github.ref_name }}"
          echo "Tests Skipped: ${{ github.event.inputs.skip_tests }}"
          echo "Rebuild Containers: ${{ github.event.inputs.rebuild_containers }}"
          echo ""
          if [ "${{ needs.setup.outputs.environment }}" = "production" ]; then
            echo "üöÄ Production deployment - using existing images from staging"
            echo "üì¶ No new images will be built for production"
          else
            echo "üèóÔ∏è Staging deployment - images will be built if needed"
          fi

      - name: Deploy to ${{ needs.setup.outputs.environment }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.setup.outputs.environment == 'production' && secrets.DEPLOY_HOST || secrets.STAGING_DEPLOY_HOST }}
          username: ${{ needs.setup.outputs.environment == 'production' && secrets.DEPLOY_USERNAME || secrets.STAGING_DEPLOY_USERNAME }}
          key: ${{ needs.setup.outputs.environment == 'production' && secrets.DEPLOY_SSH_KEY || secrets.STAGING_DEPLOY_SSH_KEY }}
          timeout: 20m
          command_timeout: 20m
          script: |
            set -e
            
            BRANCH="${{ github.event.inputs.branch || github.ref_name }}"
            ENVIRONMENT="${{ needs.setup.outputs.environment }}"
            DOMAIN="${{ needs.setup.outputs.domain }}"
            
            echo "üîÑ Starting deployment process for $ENVIRONMENT environment"
            echo "üåê Domain: $DOMAIN"
            echo "üåü Branch: $BRANCH"
            
            # Production safety check
            if [ "$ENVIRONMENT" = "production" ]; then
              echo "‚ö†Ô∏è  PRODUCTION DEPLOYMENT WARNING"
              echo "Environment: PRODUCTION"
              echo "Domain: $DOMAIN"
              echo "Branch: $BRANCH"
              echo "Triggered by: ${{ github.actor }}"
              echo "üöÄ Proceeding with production deployment..."
              sleep 3
            fi
            
            # Navigate to project directory and set environment variables
            if [ "$ENVIRONMENT" = "production" ]; then
              cd /home/deploy/Fluently-fork
              export ZEROTIER_IP="${{ secrets.ZEROTIER_IP }}"
              BACKUP_DIR="/home/deploy/backups"
            else
              cd /home/deploy-staging/Fluently-fork
              export ZEROTIER_IP="${{ secrets.STAGING_ZEROTIER_IP }}"
              BACKUP_DIR="/home/deploy-staging/backups"
            fi
            
            # Create backup directory if it doesn't exist
            mkdir -p "$BACKUP_DIR"
            
            # Function to perform health checks
            check_health() {
              echo "üè• Performing comprehensive health checks..."
              
              # Wait for services to start
              sleep 10
              
              # Check if backend is healthy
              echo "Checking backend health..."
              for i in {1..10}; do
                if curl -f "http://localhost:8070/health" >/dev/null 2>&1; then
                  echo "‚úÖ Backend is healthy"
                  break
                elif [ $i -eq 10 ]; then
                  echo "‚ùå Backend health check failed after 10 attempts"
                  return 1
                else
                  echo "‚è≥ Waiting for backend... (attempt $i/10)"
                  sleep 10
                fi
              done
              
              # Check if ML API is healthy (takes 2-3 minutes to initialize)
              echo "Checking ML API health..."
              for i in {1..20}; do
                if docker compose exec -T ml-api curl -f "http://localhost:8001/health" >/dev/null 2>&1; then
                  echo "‚úÖ ML API is healthy"
                  break
                elif [ $i -eq 20 ]; then
                  echo "‚ùå ML API health check failed after 20 attempts"
                  return 1
                else
                  echo "‚è≥ Waiting for ML API... (attempt $i/20)"
                  sleep 15
                fi
              done
              
              # Check if LLM API is healthy
              echo "Checking LLM API health..."
              for i in {1..10}; do
                if docker compose exec -T llm-api curl -f "http://localhost:8003/health" >/dev/null 2>&1; then
                  echo "‚úÖ LLM API is healthy"
                  break
                elif [ $i -eq 10 ]; then
                  echo "‚ùå LLM API health check failed after 10 attempts"
                  return 1
                else
                  echo "‚è≥ Waiting for LLM API... (attempt $i/10)"
                  sleep 10
                fi
              done
              
              # Check if Thesaurus API is healthy
              echo "Checking Thesaurus API health..."
              for i in {1..10}; do
                if docker compose exec -T thesaurus-api curl -f "http://localhost:8002/health" -d '{"ping":"test"}' -H "Content-Type: application/json" >/dev/null 2>&1; then
                  echo "‚úÖ Thesaurus API is healthy"
                  break
                elif [ $i -eq 10 ]; then
                  echo "‚ùå Thesaurus API health check failed after 10 attempts"
                  return 1
                else
                  echo "‚è≥ Waiting for Thesaurus API... (attempt $i/10)"
                  sleep 10
                fi
              done
              
              # Check if PostgreSQL is healthy
              echo "Checking PostgreSQL health..."
              if docker compose exec -T postgres pg_isready -U ${DB_USER:-postgres} >/dev/null 2>&1; then
                echo "‚úÖ PostgreSQL is healthy"
              else
                echo "‚ùå PostgreSQL health check failed"
                return 1
              fi
              
              # Check if Redis is healthy
              echo "Checking Redis health..."
              if docker compose exec -T redis redis-cli ping >/dev/null 2>&1; then
                echo "‚úÖ Redis is healthy"
              else
                echo "‚ùå Redis health check failed"
                return 1
              fi
              
              # Check if nginx is responding
              echo "Checking nginx health..."
              for i in {1..5}; do
                if curl -f -k "https://localhost" >/dev/null 2>&1; then
                  echo "‚úÖ Nginx is healthy"
                  break
                elif [ $i -eq 5 ]; then
                  echo "‚ùå Nginx health check failed after 5 attempts"
                  echo "üîç Nginx container status:"
                  docker compose ps nginx || true
                  echo "üîç Nginx logs:"
                  docker compose logs nginx || true
                  echo "üîç Nginx process inside container:"
                  docker compose exec -T nginx ps aux || true
                  echo "üîç Nginx configuration test:"
                  docker compose exec -T nginx nginx -t || true
                  return 1
                else
                  echo "‚è≥ Waiting for nginx... (attempt $i/5)"
                  sleep 5
                fi
              done
              
              # # Check if Directus is healthy
              # echo "Checking Directus health..."
              # for i in {1..10}; do
              #   if curl -f "http://localhost:8055/server/health" >/dev/null 2>&1; then
              #     echo "‚úÖ Directus is healthy"
              #     break
              #   elif [ $i -eq 10 ]; then
              #     echo "‚ùå Directus health check failed after 10 attempts"
              #     return 1
              #   else
              #     echo "‚è≥ Waiting for Directus... (attempt $i/10)"
              #     sleep 10
              #   fi
              # done
              
              # # Check if Prometheus is healthy
              # echo "Checking Prometheus health..."
              # for i in {1..5}; do
              #   if curl -f "http://localhost:9090/-/healthy" >/dev/null 2>&1; then
              #     echo "‚úÖ Prometheus is healthy"
              #     break
              #   elif [ $i -eq 5 ]; then
              #     echo "‚ùå Prometheus health check failed after 5 attempts"
              #     return 1
              #   else
              #     echo "‚è≥ Waiting for Prometheus... (attempt $i/5)"
              #     sleep 10
              #   fi
              # done
              
              # # Check if Grafana is healthy
              # echo "Checking Grafana health..."
              # for i in {1..10}; do
              #   if curl -f "http://localhost:3000/api/health" >/dev/null 2>&1; then
              #     echo "‚úÖ Grafana is healthy"
              #     break
              #   elif [ $i -eq 10 ]; then
              #     echo "‚ùå Grafana health check failed after 10 attempts"
              #     return 1
              #   else
              #     echo "‚è≥ Waiting for Grafana... (attempt $i/10)"
              #     sleep 10
              #   fi
              # done
              
              # # Check if Loki is healthy
              # echo "Checking Loki health..."
              # for i in {1..5}; do
              #   if curl -f "http://localhost:3100/ready" >/dev/null 2>&1; then
              #     echo "‚úÖ Loki is healthy"
              #     break
              #   elif [ $i -eq 5 ]; then
              #     echo "‚ùå Loki health check failed after 5 attempts"
              #     return 1
              #   else
              #     echo "‚è≥ Waiting for Loki... (attempt $i/5)"
              #     sleep 10
              #   fi
              # done
              
              # # Check if Node Exporter is healthy
              # echo "Checking Node Exporter health..."
              # if curl -f "http://localhost:9100/metrics" >/dev/null 2>&1; then
              #   echo "‚úÖ Node Exporter is healthy"
              # else
              #   echo "‚ùå Node Exporter health check failed"
              #   return 1
              # fi
              
              # # Check if Nginx Exporter is healthy
              # echo "Checking Nginx Exporter health..."
              # if curl -f "http://localhost:9113/metrics" >/dev/null 2>&1; then
              #   echo "‚úÖ Nginx Exporter is healthy"
              # else
              #   echo "‚ùå Nginx Exporter health check failed"
              #   return 1
              # fi
              
              # # Check if cAdvisor is healthy
              # echo "Checking cAdvisor health..."
              # if curl -f "http://localhost:8044/healthz" >/dev/null 2>&1; then
              #   echo "‚úÖ cAdvisor is healthy"
              # else
              #   echo "‚ùå cAdvisor health check failed"
              #   return 1
              # fi
              
              # Check if telegram bot is healthy
              echo "Checking telegram bot health..."
              for i in {1..3}; do
                if docker compose ps telegram-bot | grep -q "Up"; then
                  echo "‚úÖ Telegram bot is running"
                  # Check if bot can connect to Redis
                  if docker compose logs telegram-bot | grep -q "Successfully connected to Redis"; then
                    echo "‚úÖ Telegram bot connected to Redis"
                  fi
                  if docker compose logs telegram-bot | grep -q "telegram: Not Found (404)"; then
                    echo "‚ùå Telegram bot has invalid token (404 error)"
                    echo "üîç Bot logs:"
                    docker compose logs --tail=10 telegram-bot || true
                    return 1
                  fi
                  break
                elif [ $i -eq 3 ]; then
                  echo "‚ùå Telegram bot health check failed"
                  echo "üîç Bot logs:"
                  docker compose logs --tail=10 telegram-bot || true
                  return 1
                else
                  echo "‚è≥ Waiting for telegram bot... (attempt $i/3)"
                  sleep 5
                fi
              done
              
              # Check if Promtail is healthy (log aggregator)
              echo "Checking Promtail health..."
              if docker compose ps promtail | grep -q "Up"; then
                echo "‚úÖ Promtail is running"
              else
                echo "‚ùå Promtail health check failed"
                return 1
              fi
              
              echo "üéâ All health checks passed!"
              return 0
            }
            
            # Function to rollback
            rollback() {
              echo "üîÑ Rolling back to previous version..."
              
              # Find the latest backup
              LATEST_BACKUP=$(ls -t "$BACKUP_DIR"/fluently-backup-*.tar.gz 2>/dev/null | head -1)
              
              if [ -z "$LATEST_BACKUP" ]; then
                echo "‚ùå No backup found for rollback!"
                return 1
              fi
              
              echo "üì¶ Found backup: $LATEST_BACKUP"
              
              # Stop current services
              docker compose down --remove-orphans || true
              
              # Create rollback backup of current state
              ROLLBACK_BACKUP="$BACKUP_DIR/fluently-rollback-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
              tar -czf "$ROLLBACK_BACKUP" --exclude=node_modules --exclude=.git . || echo "‚ö†Ô∏è Rollback backup failed"
              
              # Restore from backup
              tar -xzf "$LATEST_BACKUP" --exclude=node_modules --exclude=.git .
              
              # Start services
              docker compose up -d --force-recreate
              
              # Verify rollback
              if check_health; then
                echo "‚úÖ Rollback completed successfully!"
                return 0
              else
                echo "‚ùå Rollback failed health checks!"
                return 1
              fi
            }
            
            # Handle rollback request
            if [ "$IS_ROLLBACK" = "true" ]; then
              rollback
              exit $?
            fi
            
            # Backup current state (only for production)
            if [ "$ENVIRONMENT" = "production" ]; then
              echo "üì¶ Creating backup..."
              BACKUP_FILE="$BACKUP_DIR/fluently-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
              tar -czf "$BACKUP_FILE" --exclude=node_modules --exclude=.git . || echo "‚ö†Ô∏è Backup failed but continuing..."
              
              # Keep only last 5 backups
              ls -t "$BACKUP_DIR"/fluently-backup-*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
            fi
            
            # Store current state for potential rollback
            CURRENT_STATE_BACKUP="$BACKUP_DIR/fluently-current-state-$(date +%Y%m%d-%H%M%S).tar.gz"
            tar -czf "$CURRENT_STATE_BACKUP" --exclude=node_modules --exclude=.git . || echo "‚ö†Ô∏è Current state backup failed"
            
            # Update code
            echo "üì• Updating code..."

            # Fix Git ownership issue
            git config --global --add safe.directory $(pwd)

            # Restore any local changes before pulling
            git restore .

            git fetch origin
            git checkout $BRANCH
            git pull origin $BRANCH

            # Update environment variables based on deployment target
            echo "‚öôÔ∏è Updating environment configuration..."

            # Ensure .env file exists at project root
            if [ ! -f ".env" ]; then
              echo "üìù Creating .env file at project root..."
              touch .env
            else
              echo "üìù .env file already exists, updating..."
            fi

            # Update ZeroTier IP in root .env
            if grep -q "ZEROTIER_IP=" .env; then
              sed -i "s/ZEROTIER_IP=.*/ZEROTIER_IP=$ZEROTIER_IP/" .env
            else
              echo "ZEROTIER_IP=$ZEROTIER_IP" >> .env
            fi

            # Update PUBLIC_URL in root .env
            if grep -q "PUBLIC_URL=" .env; then
              sed -i "s|PUBLIC_URL=.*|PUBLIC_URL=https://$DOMAIN|g" .env
            else
              echo "PUBLIC_URL=https://$DOMAIN" >> .env
            fi

            
            # Set Swagger host for the environment
            if [ "$ENVIRONMENT" = "production" ]; then
              export SWAGGER_HOST="${{ secrets.ZEROTIER_IP }}:8070"
            else
              export SWAGGER_HOST="${{ secrets.STAGING_ZEROTIER_IP }}:8070"
            fi
            
            echo "üîß Setting up environment variables..."
            echo "SWAGGER_HOST=$SWAGGER_HOST"
            
            # Add SWAGGER_HOST to .env file
            echo "SWAGGER_HOST=$SWAGGER_HOST" >> .env
            
            # Add telegram bot environment variables if they don't exist
            echo "üîß Setting up Telegram bot configuration..."
            if [ "$ENVIRONMENT" = "production" ]; then
              BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
              WEBHOOK_SECRET="${{ secrets.WEBHOOK_SECRET }}"
              echo "üìù Using production bot credentials"
            else
              BOT_TOKEN="${{ secrets.STAGING_TELEGRAM_BOT_TOKEN }}"
              WEBHOOK_SECRET="${{ secrets.STAGING_WEBHOOK_SECRET }}"
              echo "üìù Using staging bot credentials"
            fi
            
            # Debug: Check if secrets are provided (without printing actual values)
            if [ -z "$BOT_TOKEN" ]; then
              echo "‚ö†Ô∏è WARNING: BOT_TOKEN is empty for $ENVIRONMENT environment!"
              echo "Please set the following GitHub secret:"
              if [ "$ENVIRONMENT" = "production" ]; then
                echo "   TELEGRAM_BOT_TOKEN"
              else
                echo "   STAGING_TELEGRAM_BOT_TOKEN"
              fi
            else
              echo "‚úÖ BOT_TOKEN is provided (length: ${#BOT_TOKEN} characters)"
            fi
            
            if [ -z "$WEBHOOK_SECRET" ]; then
              echo "‚ö†Ô∏è WARNING: WEBHOOK_SECRET is empty for $ENVIRONMENT environment!"
              echo "Please set the following GitHub secret:"
              if [ "$ENVIRONMENT" = "production" ]; then
                echo "   WEBHOOK_SECRET"
              else
                echo "   STAGING_WEBHOOK_SECRET"
              fi
            else
              echo "‚úÖ WEBHOOK_SECRET is provided"
            fi
            
            # Set telegram bot configuration in root .env
            if [ ! -z "$BOT_TOKEN" ]; then
              if grep -q "BOT_TOKEN=" .env; then
                sed -i "s/BOT_TOKEN=.*/BOT_TOKEN=$BOT_TOKEN/" .env
              else
                echo "BOT_TOKEN=$BOT_TOKEN" >> .env
              fi
              echo "‚úÖ BOT_TOKEN set in .env file"
            else
              echo "‚ùå Skipping BOT_TOKEN setup (empty value)"
            fi
            
            if [ ! -z "$WEBHOOK_SECRET" ]; then
              if grep -q "WEBHOOK_SECRET=" .env; then
                sed -i "s/WEBHOOK_SECRET=.*/WEBHOOK_SECRET=$WEBHOOK_SECRET/" .env
              else
                echo "WEBHOOK_SECRET=$WEBHOOK_SECRET" >> .env
              fi
              echo "‚úÖ WEBHOOK_SECRET set in .env file"
            else
              echo "‚ùå Skipping WEBHOOK_SECRET setup (empty value)"
            fi
            
            # Set webhook URL
            if grep -q "WEBHOOK_URL=" .env; then
              sed -i "s|WEBHOOK_URL=.*|WEBHOOK_URL=https://$DOMAIN/webhook|g" .env
            else
              echo "WEBHOOK_URL=https://$DOMAIN/webhook" >> .env
            fi
            
            # Set Redis configuration for Docker network
            if grep -q "REDIS_ADDR=" .env; then
              sed -i "s|REDIS_ADDR=.*|REDIS_ADDR=redis:6379|g" .env
            else
              echo "REDIS_ADDR=redis:6379" >> .env
            fi

            # Set LLM API keys configuration
            echo "üîß Setting up LLM API keys configuration..."
            
            # Groq API keys
            GROQ_API_KEYS="${{ secrets.GROQ_API_KEYS }}"
            if [ ! -z "$GROQ_API_KEYS" ]; then
              if grep -q "GROQ_API_KEYS=" .env; then
                sed -i "s/GROQ_API_KEYS=.*/GROQ_API_KEYS=$GROQ_API_KEYS/" .env
              else
                echo "GROQ_API_KEYS=$GROQ_API_KEYS" >> .env
              fi
              echo "‚úÖ GROQ_API_KEYS set in .env file"
            else
              echo "‚ö†Ô∏è WARNING: GROQ_API_KEYS is empty! LLM API may not work properly."
              echo "Please set the GROQ_API_KEYS GitHub secret with comma-separated API keys."
            fi
            
            # Gemini API keys
            GEMINI_API_KEYS="${{ secrets.GEMINI_API_KEYS }}"
            if [ ! -z "$GEMINI_API_KEYS" ]; then
              if grep -q "GEMINI_API_KEYS=" .env; then
                sed -i "s/GEMINI_API_KEYS=.*/GEMINI_API_KEYS=$GEMINI_API_KEYS/" .env
              else
                echo "GEMINI_API_KEYS=$GEMINI_API_KEYS" >> .env
              fi
              echo "‚úÖ GEMINI_API_KEYS set in .env file"
            else
              echo "‚ö†Ô∏è WARNING: GEMINI_API_KEYS is empty! LLM API may not work properly."
              echo "Please set the GEMINI_API_KEYS GitHub secret with comma-separated API keys."
            fi

            echo "üìã Main .env file ready for docker-compose..."
            
            # Debug: Show telegram bot configuration (without sensitive values)
            echo "üîç Telegram bot configuration in .env:"
            echo "BOT_TOKEN: $(grep "BOT_TOKEN=" .env | sed 's/BOT_TOKEN=.*/BOT_TOKEN=[HIDDEN]/' || echo 'Not set')"
            echo "WEBHOOK_SECRET: $(grep "WEBHOOK_SECRET=" .env | sed 's/WEBHOOK_SECRET=.*/WEBHOOK_SECRET=[HIDDEN]/' || echo 'Not set')"
            echo "WEBHOOK_URL: $(grep "WEBHOOK_URL=" .env || echo 'Not set')"
            echo "REDIS_ADDR: $(grep "REDIS_ADDR=" .env || echo 'Not set')"
            
            # Debug: Show LLM API keys configuration (without sensitive values)
            echo "üîç LLM API keys configuration in .env:"
            echo "GROQ_API_KEYS: $(grep "GROQ_API_KEYS=" .env | sed 's/GROQ_API_KEYS=.*/GROQ_API_KEYS=[HIDDEN]/' || echo 'Not set')"
            echo "GEMINI_API_KEYS: $(grep "GEMINI_API_KEYS=" .env | sed 's/GEMINI_API_KEYS=.*/GEMINI_API_KEYS=[HIDDEN]/' || echo 'Not set')"
            

            # Generate nginx config from template
            echo "üîß Generating nginx configuration from template..."
            if [ "$ENVIRONMENT" = "production" ]; then
              export CERT_NAME="fluently-app-ru"
            else
              export CERT_NAME="fluently-app-online"
            fi

            export DOMAIN
            # Specify which variables to substitute, leaving nginx variables untouched
            envsubst '${DOMAIN} ${CERT_NAME}' < backend/nginx-container/nginx.conf.template > backend/nginx-container/default.conf

            echo "Generated nginx config for $DOMAIN with cert $CERT_NAME"

            # Check disk space before deployment
            echo "üìä Disk space before deployment:"
            df -h | grep -E "(overlay|docker|/$)"
            
            echo "üê≥ Pulling latest images and starting containers..."
            # Stop services first
            docker compose down --remove-orphans || true

            # Clean up Docker networks to prevent conflicts
            echo "üßπ Cleaning up Docker networks..."
            
            # Remove project-specific networks if they exist
            docker network rm fluently-fork_fluently_network 2>/dev/null || true
            docker network rm fluently_network 2>/dev/null || true
            
            # Prune unused networks
            docker network prune -f || true
            
            echo "‚úÖ Network cleanup completed"

            # Pull latest images instead of building
            echo "üì• Pulling latest Docker images..."
            docker compose pull
            
            # Start services with force recreate
            echo "üöÄ Starting services..."
            if [ "${{ github.event.inputs.rebuild_containers }}" = "true" ]; then
              echo "üî® Rebuilding containers during deployment..."
              docker compose up -d --force-recreate --build
            else
              docker compose up -d --force-recreate
            fi

            # Perform health checks
            if check_health; then
              echo "üéâ Deployment completed successfully!"
              echo "üåê Application available at: https://$DOMAIN"
              echo "üïê Deployment time: $(date)"
              echo "üë§ Deployed by: ${{ github.actor }}"
              echo "üåø Branch: $BRANCH"
              echo "üè∑Ô∏è  Environment: $ENVIRONMENT"
              
              # Show running containers
              echo ""
              echo "üìã Running containers:"
              docker compose ps
              
              # Show telegram bot setup instructions
              echo ""
              echo "ü§ñ Telegram Bot Setup Instructions:"
              echo "If the bot token is set correctly, run this command to set up the webhook:"
              echo ""
              echo "curl -X POST \"https://api.telegram.org/bot\$BOT_TOKEN/setWebhook\" \\"
              echo "     -H \"Content-Type: application/json\" \\"
              echo "     -d '{\"url\": \"https://$DOMAIN/webhook\"}'"
              echo ""
              echo "Replace \$BOT_TOKEN with your actual bot token from the GitHub secrets."
              echo "You can test the webhook by sending a message to your bot."
              echo ""
              
              # Enhanced cleanup old images and free up space
              echo "üßπ Performing comprehensive Docker cleanup..."
              
              # Protect critical volumes first
              echo "üîí Verifying critical volumes are protected..."
              CRITICAL_VOLUMES="fluently_pgdata_safe fluently_grafana_data_external"
              for vol in $CRITICAL_VOLUMES; do
                if docker volume ls | grep -q "$vol"; then
                  echo "‚úÖ Critical volume protected: $vol"
                else
                  echo "‚ö†Ô∏è Warning: Critical volume not found: $vol"
                fi
              done
              
              # Remove old image versions (keep last 3 versions of each fluently image)
              echo "üóëÔ∏è Cleaning up old fluently images (keeping last 3 versions)..."
              docker images --format "{{.Repository}}:{{.Tag}} {{.ID}} {{.CreatedAt}}" | \
                grep "fluentlyorg/fluently-" | \
                sort -k3 -r | \
                tail -n +4 | \
                awk '{print $2}' | \
                xargs -r docker rmi -f 2>/dev/null || true
              
              # Clean up dangling and old unused images
              echo "üóëÔ∏è Cleaning up dangling images..."
              docker image prune -f || true
              
              echo "üóëÔ∏è Cleaning up images older than 72 hours (not in use)..."
              docker image prune -a --filter "until=72h" -f || true
              
              # Clean up build cache to free space
              echo "üóëÔ∏è Cleaning up Docker build cache..."
              docker builder prune -f || true
              
              # Clean up unused networks (safe - only removes unattached networks)
              echo "üóëÔ∏è Cleaning up unused networks..."
              docker network prune -f || true
              
              # Clean up stopped containers (safe - only removes stopped containers)
              echo "üóëÔ∏è Cleaning up stopped containers..."
              docker container prune -f || true
              
              # INTENTIONALLY SKIP volume prune to protect data
              echo "üîí Skipping volume cleanup to protect database data"
              
              # Show cleanup results
              echo "üìä Disk space after cleanup:"
              df -h | grep -E "(overlay|docker|/$)" || true
              
              echo "üì¶ Remaining Docker images:"
              docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
              
              # Cleanup old images (keep last 3)
              echo "‚úÖ Docker cleanup completed safely"
              
              # Remove current state backup since deployment was successful
              rm -f "$CURRENT_STATE_BACKUP" || true
              
            else
              echo "‚ùå Deployment failed health checks! Starting rollback..."
              
              # Restore from current state backup
              echo "üîÑ Restoring previous state..."
              docker compose down --remove-orphans || true
              tar -xzf "$CURRENT_STATE_BACKUP" --exclude=node_modules --exclude=.git . || echo "‚ö†Ô∏è Restore failed"
              docker compose up -d --force-recreate
              
              # Cleanup failed backup
              rm -f "$CURRENT_STATE_BACKUP" || true
              
              echo "‚ùå Deployment failed and rollback attempted"
              exit 1
            fi

  # ===========================================
  # CLEANUP STAGE - Clean up old Docker Hub images
  # ===========================================
  cleanup:
    name: Clean Up Docker Hub Images
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub for cleanup
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Clean up old Docker Hub images
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Function to get Docker Hub token
          get_docker_token() {
            local username=$1
            local password=$2
            local repo=$3
            
            curl -s -H "Content-Type: application/json" \
              -X POST \
              -d "{\"username\": \"$username\", \"password\": \"$password\"}" \
              https://hub.docker.com/v2/users/login/ | jq -r .token
          }
          
          # Function to delete old images from a repository
          cleanup_repo() {
            local repo=$1
            local keep_count=${2:-5}
            
            echo "üßπ Cleaning up repository: $repo"
            
            # Get auth token
            TOKEN=$(get_docker_token "$DOCKERHUB_USERNAME" "$DOCKERHUB_TOKEN" "$repo")
            
            if [ "$TOKEN" = "null" ] || [ -z "$TOKEN" ]; then
              echo "‚ùå Failed to get Docker Hub token for $repo"
              return 1
            fi
            
            # Get list of tags (we'll focus on latest-develop and older manifests)
            TAGS=$(curl -s -H "Authorization: JWT $TOKEN" \
              "https://hub.docker.com/v2/repositories/$repo/tags/?page_size=100" | \
              jq -r '.results[] | select(.name == "latest-develop") | .digest' | head -1)
            
            if [ -z "$TAGS" ]; then
              echo "‚ÑπÔ∏è No latest-develop tag found in $repo, skipping cleanup"
              return 0
            fi
            
            # Get all manifests for the repository
            MANIFESTS=$(curl -s -H "Authorization: JWT $TOKEN" \
              "https://hub.docker.com/v2/repositories/$repo/tags/?page_size=100" | \
              jq -r '.results[] | .digest' | sort | uniq)
            
            # Count total manifests
            TOTAL_COUNT=$(echo "$MANIFESTS" | wc -l)
            echo "üìä Found $TOTAL_COUNT total manifests in $repo"
            
            if [ "$TOTAL_COUNT" -le "$keep_count" ]; then
              echo "‚úÖ Repository $repo has $TOTAL_COUNT manifests (‚â§ $keep_count), no cleanup needed"
              return 0
            fi
            
            # Get manifests to delete (all except the most recent ones)
            MANIFESTS_TO_DELETE=$(echo "$MANIFESTS" | head -n -$keep_count)
            DELETE_COUNT=$(echo "$MANIFESTS_TO_DELETE" | wc -l)
            
            echo "üóëÔ∏è Will delete $DELETE_COUNT old manifests from $repo, keeping the $keep_count most recent"
            
            # Delete old manifests
            DELETED=0
            for digest in $MANIFESTS_TO_DELETE; do
              if [ -n "$digest" ] && [ "$digest" != "null" ]; then
                echo "üóëÔ∏è Deleting manifest: $digest"
                RESPONSE=$(curl -s -X DELETE \
                  -H "Authorization: JWT $TOKEN" \
                  "https://hub.docker.com/v2/repositories/$repo/tags/$digest/")
                
                if [ $? -eq 0 ]; then
                  DELETED=$((DELETED + 1))
                  echo "‚úÖ Deleted manifest $digest"
                else
                  echo "‚ùå Failed to delete manifest $digest"
                fi
                
                # Rate limiting - be nice to Docker Hub
                sleep 1
              fi
            done
            
            echo "‚úÖ Cleanup completed for $repo: deleted $DELETED manifests"
          }
          
          # Install jq for JSON parsing
          sudo apt-get update && sudo apt-get install -y jq
          
          # Clean up each repository
          echo "üöÄ Starting Docker Hub cleanup process..."
          
          cleanup_repo "fluentlyorg/fluently-backend" 2
          cleanup_repo "fluentlyorg/fluently-telegram-bot" 2 
          cleanup_repo "fluentlyorg/fluently-ml-api" 2
          cleanup_repo "fluentlyorg/fluently-nginx" 2
          
          echo "‚úÖ Docker Hub cleanup process completed!"

