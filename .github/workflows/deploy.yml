name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - production
          - staging
      rollback:
        description: "Rollback to previous version"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: docker.io
  IMAGE_TAG: ${{ github.sha }}
  
jobs:
  # ===========================================
  # BUILD STAGE - Build all Docker images
  # ===========================================
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.event_name == 'pull_request'
    outputs:
      image-tag: ${{ env.IMAGE_TAG }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/fluentlyorg/fluently-backend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata for telegram-bot
        id: meta-telegram
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/fluentlyorg/fluently-telegram-bot
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata for ml-api
        id: meta-ml-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/fluentlyorg/fluently-ml-api
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata for nginx
        id: meta-nginx
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/fluentlyorg/fluently-nginx
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            SWAGGER_HOST=localhost:8070

      - name: Build and push telegram-bot image
        uses: docker/build-push-action@v5
        with:
          context: ./telegram-bot
          file: ./telegram-bot/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta-telegram.outputs.tags }}
          labels: ${{ steps.meta-telegram.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push ML API image
        uses: docker/build-push-action@v5
        with:
          context: ./analysis
          file: ./analysis/distractor_api/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta-ml-api.outputs.tags }}
          labels: ${{ steps.meta-ml-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push nginx image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./backend/nginx-container/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta-nginx.outputs.tags }}
          labels: ${{ steps.meta-nginx.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ===========================================
  # TEST STAGE - Run tests and quality checks
  # ===========================================
  test:
    name: Test & Quality Checks
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop' || github.event_name == 'pull_request'
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_fluently_db
        ports:
          - 5433:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          cache: true
          cache-dependency-path: backend/go.sum

      - name: Install swag for Go docs generation
        run: |
          echo "üì¶ Installing swag..."
          go install github.com/swaggo/swag/cmd/swag@latest
          echo "‚úÖ Swag installed to: $(which swag || echo '$HOME/go/bin/swag')"

      - name: Generate Go API documentation
        working-directory: ./backend
        run: |
          export PATH=$PATH:$HOME/go/bin
          
          echo "üì¶ Ensuring Go dependencies are available..."
          go mod download
          go mod tidy
          
          echo "üîç Checking for main.go:"
          test -f cmd/main.go && echo "‚úÖ cmd/main.go exists" || echo "‚ùå cmd/main.go missing"
          
          # Create docs directory
          mkdir -p docs
          
          # Generate Swagger documentation
          echo "üìö Generating API documentation..."
          if command -v swag >/dev/null 2>&1; then
            SWAG_CMD="swag"
          elif [ -f "$HOME/go/bin/swag" ]; then
            SWAG_CMD="$HOME/go/bin/swag"
          else
            echo "‚ùå swag not found"
            exit 1
          fi
          
          $SWAG_CMD init -g ./cmd/main.go -o ./docs --parseDependency --parseInternal || \
          $SWAG_CMD init -g ./cmd/main.go -o ./docs --parseDependency || \
          $SWAG_CMD init -g ./cmd/main.go -o ./docs
          
          echo "‚úÖ Documentation generated successfully"

      - name: Run Go tests with coverage
        working-directory: ./backend
        env:
          DB_HOST: localhost
          DB_PORT: 5433
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_fluently_db
          DB_TEST_HOST: localhost
          DB_TEST_PORT: 5433
          DB_TEST_USER: test_user
          DB_TEST_PASSWORD: test_password
          DB_TEST_NAME: test_fluently_db
          REDIS_ADDR: localhost:6379
        run: |
          echo "üß™ Running Go tests with coverage..."
          go test ./... -coverprofile=coverage.out -covermode=atomic
          go tool cover -func=coverage.out

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v3.1.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Login to Docker Hub for testing
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Test Docker containers integration
        if: github.event_name != 'pull_request'
        run: |
          echo "üê≥ Testing Docker containers integration..."
          
          # Create test docker-compose file with built images
          cat > docker-compose.test-integration.yml << EOF
          services:
            postgres:
              image: postgres:15-alpine
              environment:
                POSTGRES_USER: test_user
                POSTGRES_PASSWORD: test_password
                POSTGRES_DB: test_fluently_db
              ports:
                - "5434:5432"
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U test_user"]
                interval: 10s
                timeout: 5s
                retries: 5
            
            redis:
              image: redis:7-alpine
              ports:
                - "6380:6379"
              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 10s
                timeout: 5s
                retries: 5
            
            backend:
              image: ${{ env.REGISTRY }}/fluentlyorg/fluently-backend:develop-${{ github.sha }}
              environment:
                DB_HOST: postgres
                DB_PORT: 5432
                DB_USER: test_user
                DB_PASSWORD: test_password
                DB_NAME: test_fluently_db
                REDIS_ADDR: redis:6379
                PUBLIC_URL: http://localhost:8070
              ports:
                - "8071:8070"
              depends_on:
                postgres:
                  condition: service_healthy
                redis:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8070/health"]
                interval: 30s
                timeout: 10s
                retries: 3
          EOF
          
          # Start services
          docker compose -f docker-compose.test-integration.yml up -d
          
          # Wait for backend to be healthy
          echo "‚è≥ Waiting for backend to be healthy..."
          for i in {1..10}; do
            if curl -f http://localhost:8071/health >/dev/null 2>&1; then
              echo "‚úÖ Backend is healthy"
              break
            elif [ $i -eq 10 ]; then
              echo "‚ùå Backend health check failed"
              docker compose -f docker-compose.test-integration.yml logs
              exit 1
            else
              echo "‚è≥ Waiting for backend... (attempt $i/10)"
              sleep 15
            fi
          done
          
          # Cleanup
          docker compose -f docker-compose.test-integration.yml down --volumes

  # ===========================================
  # PUBLISH STAGE - Push images to registry
  # ===========================================
  publish:
    name: Publish Images
    runs-on: ubuntu-latest
    needs: [build, test]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag and push stable images
        run: |
          echo "üè∑Ô∏è Tagging and pushing stable images..."
          
          # Pull the SHA-tagged images and re-tag as stable
          IMAGES=(
            "fluentlyorg/fluently-backend"
            "fluentlyorg/fluently-telegram-bot" 
            "fluentlyorg/fluently-ml-api"
            "fluentlyorg/fluently-nginx"
          )
          
          for image in "${IMAGES[@]}"; do
            echo "Processing $image..."
            
            # Pull the develop-SHA tagged image
            docker pull ${{ env.REGISTRY }}/$image:develop-${{ github.sha }}
            
            # Tag as latest-develop for stable development builds
            docker tag ${{ env.REGISTRY }}/$image:develop-${{ github.sha }} ${{ env.REGISTRY }}/$image:latest-develop
            
            # Push the stable tag
            docker push ${{ env.REGISTRY }}/$image:latest-develop
          done
          
          echo "‚úÖ All images published successfully!"

  # ===========================================
  # DEPLOY STAGE - Deploy to production
  # ===========================================
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USERNAME }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          timeout: 30m
          command_timeout: 30m
          script: |
            set -e
            
            echo "üöÄ Starting production deployment..."
            cd /home/deploy/Fluently-fork
            
            # Create backup
            echo "üì¶ Creating backup..."
            BACKUP_DIR="/home/deploy/backups"
            mkdir -p "$BACKUP_DIR"
            BACKUP_FILE="$BACKUP_DIR/fluently-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
            tar -czf "$BACKUP_FILE" --exclude=node_modules --exclude=.git . || echo "‚ö†Ô∏è Backup failed"
            
            # Keep only last 5 backups
            ls -t "$BACKUP_DIR"/fluently-backup-*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
            
            # Update code
            echo "üì• Updating code..."
            git config --global --add safe.directory $(pwd)
            git fetch origin
            git checkout main
            git pull origin main
            
            # Create production docker-compose file with pre-built images
            echo "üê≥ Creating production docker-compose configuration..."
            cat > docker-compose.production.yml << 'EOF'
            services:
              backend:
                image: docker.io/fluentlyorg/fluently-backend:latest-develop
                container_name: fluently_backend
                environment:
                  DB_HOST: postgres
                  DB_PORT: 5432
                  DB_USER: ${DB_USER:-postgres}
                  DB_PASSWORD: ${DB_PASSWORD}
                  DB_NAME: ${DB_NAME:-fluently_db}
                  REDIS_ADDR: redis:6379
                  PUBLIC_URL: https://${DOMAIN}
                  ZEROTIER_IP: ${ZEROTIER_IP}
                depends_on:
                  postgres:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                restart: unless-stopped
                networks:
                  - fluently_network
                ports:
                  - "127.0.0.1:8070:8070"
                  - "${ZEROTIER_IP}:8070:8070"
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8070/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
              
              telegram-bot:
                image: docker.io/fluentlyorg/fluently-telegram-bot:latest-develop
                container_name: fluently_telegram_bot
                environment:
                  BOT_TOKEN: ${BOT_TOKEN}
                  WEBHOOK_SECRET: ${WEBHOOK_SECRET}
                  WEBHOOK_URL: https://${DOMAIN}/webhook
                  REDIS_ADDR: redis:6379
                  BACKEND_URL: http://backend:8070
                depends_on:
                  redis:
                    condition: service_healthy
                  backend:
                    condition: service_healthy
                restart: unless-stopped
                networks:
                  - fluently_network
              
              ml-api:
                image: docker.io/fluentlyorg/fluently-ml-api:latest-develop
                container_name: fluently_ml_api
                restart: unless-stopped
                networks:
                  - fluently_network
                ports:
                  - "127.0.0.1:8001:8001"
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
                  interval: 60s
                  timeout: 30s
                  retries: 3
                  start_period: 180s
              
              nginx:
                image: docker.io/fluentlyorg/fluently-nginx:latest-develop
                container_name: fluently_nginx
                environment:
                  DOMAIN: ${DOMAIN}
                  CERT_NAME: ${CERT_NAME}
                  WEBHOOK_SECRET: ${WEBHOOK_SECRET}
                ports:
                  - "80:80"
                  - "443:443"
                depends_on:
                  - backend
                volumes:
                  - /etc/nginx/ssl:/etc/nginx/ssl:ro
                networks:
                  - fluently_network
              
              postgres:
                image: postgres:15-alpine
                container_name: fluently_postgres
                environment:
                  POSTGRES_USER: ${DB_USER:-postgres}
                  POSTGRES_PASSWORD: ${DB_PASSWORD}
                  POSTGRES_DB: ${DB_NAME:-fluently_db}
                volumes:
                  - fluently_postgres_data:/var/lib/postgresql/data
                  - ./backend/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
                restart: unless-stopped
                networks:
                  - fluently_network
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres}"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
              
              redis:
                image: redis:7-alpine
                container_name: fluently_redis
                restart: unless-stopped
                networks:
                  - fluently_network
                volumes:
                  - fluently_redis_data:/data
                healthcheck:
                  test: ["CMD", "redis-cli", "ping"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
            
            volumes:
              fluently_postgres_data:
                external: true
              fluently_redis_data:
                external: true
            
            networks:
              fluently_network:
                driver: bridge
            EOF
            
            # Setup environment variables
            echo "‚öôÔ∏è Setting up environment variables..."
            if [ ! -f ".env" ]; then
              cp .env.example .env
            fi
            
            # Update environment variables
            sed -i "s/ZEROTIER_IP=.*/ZEROTIER_IP=${{ secrets.ZEROTIER_IP }}/" .env
            sed -i "s|PUBLIC_URL=.*|PUBLIC_URL=https://fluently-app.ru|g" .env
            sed -i "s/DOMAIN=.*/DOMAIN=fluently-app.ru/" .env
            sed -i "s/CERT_NAME=.*/CERT_NAME=fluently-app-ru/" .env
            
            # Set telegram bot configuration
            if [ ! -z "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then
              sed -i "s/BOT_TOKEN=.*/BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}/" .env
            fi
            if [ ! -z "${{ secrets.WEBHOOK_SECRET }}" ]; then
              sed -i "s/WEBHOOK_SECRET=.*/WEBHOOK_SECRET=${{ secrets.WEBHOOK_SECRET }}/" .env
            fi
            
            # Pull latest images
            echo "üì• Pulling latest production images..."
            docker compose -f docker-compose.production.yml pull
            
            # Stop current services
            echo "üõë Stopping current services..."
            docker compose down --remove-orphans || true
            
            # Start new services
            echo "üöÄ Starting production services..."
            docker compose -f docker-compose.production.yml up -d
            
            # Health checks
            echo "üè• Performing health checks..."
            sleep 30
            
            # Check backend health
            for i in {1..10}; do
              if curl -f "http://localhost:8070/health" >/dev/null 2>&1; then
                echo "‚úÖ Backend is healthy"
                break
              elif [ $i -eq 10 ]; then
                echo "‚ùå Backend health check failed"
                exit 1
              else
                echo "‚è≥ Waiting for backend... (attempt $i/10)"
                sleep 15
              fi
            done
            
            # Check nginx
            for i in {1..5}; do
              if curl -f -s "http://localhost" >/dev/null 2>&1; then
                echo "‚úÖ Nginx is healthy"
                break
              elif [ $i -eq 5 ]; then
                echo "‚ùå Nginx health check failed"
                docker compose -f docker-compose.production.yml logs nginx
                exit 1
              else
                echo "‚è≥ Waiting for nginx... (attempt $i/5)"
                sleep 10
              fi
            done
            
            echo "üéâ Production deployment completed successfully!"
            echo "üåê Application available at: https://fluently-app.ru"
            
            # Show running containers
            docker compose -f docker-compose.production.yml ps

  # ===========================================
  # STAGING DEPLOY - Deploy to staging
  # ===========================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    needs: [build, test, publish]
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_DEPLOY_HOST }}
          username: ${{ secrets.STAGING_DEPLOY_USERNAME }}
          key: ${{ secrets.STAGING_DEPLOY_SSH_KEY }}
          timeout: 30m
          command_timeout: 30m
          script: |
            set -e
            
            echo "üöÄ Starting staging deployment..."
            cd /home/deploy-staging/Fluently-fork
            
            # Update code
            echo "üì• Updating code..."
            git config --global --add safe.directory $(pwd)
            git fetch origin
            git checkout develop
            git pull origin develop
            
            # Use the same production docker-compose but with staging config
            cp docker-compose.production.yml docker-compose.staging.yml
            
            # Setup staging environment
            echo "‚öôÔ∏è Setting up staging environment..."
            if [ ! -f ".env" ]; then
              cp .env.example .env
            fi
            
            sed -i "s/ZEROTIER_IP=.*/ZEROTIER_IP=${{ secrets.STAGING_ZEROTIER_IP }}/" .env
            sed -i "s|PUBLIC_URL=.*|PUBLIC_URL=https://fluently-app.online|g" .env
            sed -i "s/DOMAIN=.*/DOMAIN=fluently-app.online/" .env
            sed -i "s/CERT_NAME=.*/CERT_NAME=fluently-app-online/" .env
            
            if [ ! -z "${{ secrets.STAGING_TELEGRAM_BOT_TOKEN }}" ]; then
              sed -i "s/BOT_TOKEN=.*/BOT_TOKEN=${{ secrets.STAGING_TELEGRAM_BOT_TOKEN }}/" .env
            fi
            if [ ! -z "${{ secrets.STAGING_WEBHOOK_SECRET }}" ]; then
              sed -i "s/WEBHOOK_SECRET=.*/WEBHOOK_SECRET=${{ secrets.STAGING_WEBHOOK_SECRET }}/" .env
            fi
            
            # Pull and deploy
            docker compose -f docker-compose.staging.yml pull
            docker compose down --remove-orphans || true
            docker compose -f docker-compose.staging.yml up -d
            
            echo "üéâ Staging deployment completed!"
            echo "üåê Staging available at: https://fluently-app.online"
