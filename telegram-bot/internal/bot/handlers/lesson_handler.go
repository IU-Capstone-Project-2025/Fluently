package handlers

import (
	"context"
	"fmt"

	"go.uber.org/zap"
	tele "gopkg.in/telebot.v3"

	"telegram-bot/internal/api"
	"telegram-bot/internal/bot/fsm"
)

// HandleLearnCommand handles the /learn command with new learning flow
func (s *HandlerService) HandleLearnCommand(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	// Check if the user has completed the onboarding process
	userProgress, err := s.GetUserProgress(ctx, userID)
	if err != nil {
		s.logger.Error("Failed to get user progress", zap.Error(err))
		return err
	}

	// If user hasn't completed onboarding, prompt them to start
	if userProgress.CEFRLevel == "" {
		startButton := &tele.InlineButton{
			Text: "–ù–∞—á–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É",
			Data: "onboarding:start",
		}
		keyboard := &tele.ReplyMarkup{
			InlineKeyboard: [][]tele.InlineButton{
				{*startButton},
			},
		}

		return c.Send("–ü–æ—Ö–æ–∂–µ, –≤—ã –µ—â–µ –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É. "+
			"–î–∞–≤–∞–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞ –æ–ø—Ä–µ–¥–µ–ª–∏–º –≤–∞—à —É—Ä–æ–≤–µ–Ω—å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ.", keyboard)
	}

	// Start new learning flow
	return s.HandleNewLearningStart(ctx, c, userID, currentState)
}

// HandleLessonCommand handles the /lesson command (same as /learn for quick testing)
func (s *HandlerService) HandleLessonCommand(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	// For quick testing, use the same logic as /learn
	return s.HandleLearnCommand(ctx, c, userID, currentState)
}

// HandleTestCommand handles the /test command
func (s *HandlerService) HandleTestCommand(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	// Set user state to vocabulary test
	if err := s.stateManager.SetState(ctx, userID, fsm.StateVocabularyTest); err != nil {
		s.logger.Error("Failed to set vocabulary test state", zap.Error(err))
		return err
	}

	// Send test introduction message
	testText := "üß† *–¢–µ—Å—Ç —É—Ä–æ–≤–Ω—è CEFR*\n\n" +
		"–≠—Ç–æ—Ç —Ç–µ—Å—Ç –ø–æ–º–æ–∂–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤–∞—à —É—Ä–æ–≤–µ–Ω—å –≤–ª–∞–¥–µ–Ω–∏—è –∞–Ω–≥–ª–∏–π—Å–∫–∏–º —è–∑—ã–∫–æ–º —Å–æ–≥–ª–∞—Å–Ω–æ —à–∫–∞–ª–µ CEFR.\n\n" +
		"–í—ã —É–≤–∏–¥–∏—Ç–µ —Å–µ—Ä–∏—é —Å–ª–æ–≤. –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ–≤–∞ —É–∫–∞–∂–∏—Ç–µ, —Ö–æ—Ä–æ—à–æ –ª–∏ –≤—ã –µ–≥–æ –∑–Ω–∞–µ—Ç–µ.\n\n" +
		"–¢–µ—Å—Ç —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ 5 —á–∞—Å—Ç–µ–π –∏ –∑–∞–π–º–µ—Ç –æ–∫–æ–ª–æ 5-10 –º–∏–Ω—É—Ç. –ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?"

	// Create test keyboard
	keyboard := &tele.ReplyMarkup{
		InlineKeyboard: [][]tele.InlineButton{
			{
				{Text: "–ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç", Data: "test:start"},
				{Text: "–ü–æ–∑–∂–µ", Data: "menu:main"},
			},
		},
	}

	return c.Send(testText, &tele.SendOptions{ParseMode: tele.ModeMarkdown}, keyboard)
}

// HandleLessonStartCallback handles lesson start callback
func (s *HandlerService) HandleLessonStartCallback(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	s.logger.Info("HandleLessonStartCallback called", zap.Int64("user_id", userID), zap.String("current_state", string(currentState)))

	// For users in welcome state, first transition to start state
	if currentState == fsm.StateWelcome {
		if err := s.stateManager.SetState(ctx, userID, fsm.StateStart); err != nil {
			s.logger.Error("Failed to set start state from welcome", zap.Error(err))
			return err
		}
		currentState = fsm.StateStart
	}

	// Check if user is authenticated and has completed onboarding
	isAuthenticated, hasCompletedOnboarding, err := s.GetUserAuthenticationStatus(ctx, userID)
	if err != nil {
		s.logger.Error("Failed to get user authentication status", zap.Error(err))
		return err
	}

	if !isAuthenticated {
		// User is not authenticated, redirect to authentication
		return c.Send("üîê –î–ª—è –Ω–∞—á–∞–ª–∞ —É—Ä–æ–∫–æ–≤ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∏–ª–∏ –≤—Ö–æ–¥–∞.")
	}

	if !hasCompletedOnboarding {
		// User is authenticated but hasn't completed onboarding
		userProgress, err := s.GetUserProgress(ctx, userID)
		if err != nil {
			s.logger.Error("Failed to get user progress", zap.Error(err))
			return err
		}

		if userProgress.CEFRLevel == "" {
			// User hasn't set CEFR level, redirect to onboarding
			return c.Send("üìö –°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É –ø—Ä–æ—Ñ–∏–ª—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è.")
		}
	}

	// User is ready for lessons, start the lesson flow
	return s.HandleLearnCommand(ctx, c, userID, currentState)
}

// HandleLessonLaterCallback handles lesson later callback
func (s *HandlerService) HandleLessonLaterCallback(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	return c.Send("–£—Ä–æ–∫ –æ—Ç–ª–æ–∂–µ–Ω.")
}

// HandleTestSkipCallback handles test skip callback
func (s *HandlerService) HandleTestSkipCallback(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	// Get the confidence level from questionnaire to determine CEFR level
	confidenceLevel, err := s.stateManager.GetTempData(ctx, userID, fsm.TempDataConfidence)
	if err != nil {
		s.logger.Error("Failed to get confidence level", zap.Error(err))
		// Default to beginner if we can't get confidence level
		confidenceLevel = "beginner"
	}

	// Map confidence level to CEFR level
	cefrLevel := s.mapConfidenceToCEFR(confidenceLevel.(string))

	// Set the CEFR level based on user's self-assessment
	if err := s.stateManager.SetState(ctx, userID, fsm.StateCEFRTestResult); err != nil {
		s.logger.Error("Failed to set CEFR test result state", zap.Error(err))
		return err
	}

	// Store the determined CEFR level
	if err := s.stateManager.StoreTempData(ctx, userID, fsm.TempDataCEFRTest, cefrLevel); err != nil {
		s.logger.Error("Failed to store CEFR level", zap.Error(err))
	}

	// Save the CEFR level to the backend (if user is authenticated)
	token, err := s.stateManager.GetJWTToken(ctx, userID)
	if err == nil {
		// User is authenticated, save preferences to backend
		preferences := &api.UpdatePreferenceRequest{
			CEFRLevel: cefrLevel,
		}
		if _, err := s.apiClient.UpdateUserPreferences(ctx, token, preferences); err != nil {
			s.logger.Error("Failed to update user preferences with CEFR level", zap.Error(err))
		}
	}

	// Send completion message with assigned level
	completionText := fmt.Sprintf(
		"üéâ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Fluently!*\n\n"+
			"–ù–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –≤–∞—à —É—Ä–æ–≤–µ–Ω—å –∫–∞–∫ *%s*.\n\n"+
			"–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –¢–µ–ø–µ—Ä—å —Ç—ã –º–æ–∂–µ—à—å –Ω–∞—á–∞—Ç—å –∏–∑—É—á–µ–Ω–∏–µ.\n\n"+
			"–ò—Å–ø–æ–ª—å–∑—É–π /learn —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Å–≤–æ–π –ø–µ—Ä–≤—ã–π —É—Ä–æ–∫!",
		cefrLevel,
	)

	// Create main menu keyboard
	keyboard := &tele.ReplyMarkup{
		InlineKeyboard: [][]tele.InlineButton{
			{{Text: "–ù–∞—á–∞—Ç—å –∏–∑—É—á–µ–Ω–∏–µ", Data: "lesson:start"}},
			{{Text: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏", Data: "menu:settings"}},
		},
	}

	// Send the completion message and transition to start state
	if err := c.Send(completionText, &tele.SendOptions{ParseMode: tele.ModeMarkdown}, keyboard); err != nil {
		return err
	}

	// Set final state to start (onboarding complete)
	return s.stateManager.SetState(ctx, userID, fsm.StateStart)
}

// mapConfidenceToCEFR maps user confidence level to CEFR level
func (s *HandlerService) mapConfidenceToCEFR(confidenceLevel string) string {
	switch confidenceLevel {
	case "beginner":
		return "A1"
	case "elementary":
		return "A2"
	case "intermediate":
		return "B1"
	case "advanced":
		return "C1"
	default:
		return "A1" // Default to beginner
	}
}

// HandleWaitingForTranslationMessage handles translation waiting state
func (s *HandlerService) HandleWaitingForTranslationMessage(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	return c.Send("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –ø–µ—Ä–µ–≤–æ–¥.")
}

// HandleWaitingForAudioMessage handles audio waiting state
func (s *HandlerService) HandleWaitingForAudioMessage(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	return c.Send("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å—Ç–µ –∞—É–¥–∏–æ –æ—Ç–≤–µ—Ç.")
}

// HandleAudioExerciseResponse handles audio exercise responses
func (s *HandlerService) HandleAudioExerciseResponse(ctx context.Context, c tele.Context, userID int64, voice interface{}) error {
	return c.Send("–ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ –∞—É–¥–∏–æ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ.")
}

// HandleLearnMenuCallback handles learn menu callback
func (s *HandlerService) HandleLearnMenuCallback(ctx context.Context, c tele.Context, userID int64, currentState fsm.UserState) error {
	return c.Send("–ú–µ–Ω—é –æ–±—É—á–µ–Ω–∏—è...")
}
